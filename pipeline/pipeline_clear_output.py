import collections

from pipeline import pipeline_tag
from pipeline.pipeline_abstract import AbstractPipeline
from pipeline.pipeline_common import ClusteringOutput
from utils import bdsa_utils


class PipelineClearOutput(AbstractPipeline):
    """
    All specific tratments that must be done after alignment and before final analysis
    """

    def __init__(self):
        self.debug_stats = None

    def run(self, data):
        result = {}
        self.debug_stats = data[1]
        for cat, output in data[0].items():
            result[cat] = self.clear_output(output, cat)

        return result, self.debug_stats

    def name(self):
        return "PipelineClearOutput"

    def need_input(self):
        return True

    def need_output(self):
        return True

    def clear_output(self, output: ClusteringOutput, cat: str):
        """
        Remove virtual attributes still isolated, and isolated original attributes for which we found at least a
        non-isolated virtual attribute.
        :param output:
        :param cat:
        :return:
        """
        output.end_algorithm()
        #if _config_.delete_subclusters_only_virtuals():
        self._remove_useless_clusters(output)
        self._remove_contained_clusters(output)
        original_sas_of_non_isolated_virtual_sas = set()
        sas_generated_to_remove = set()
        sas_original_to_delete = set()  # original source attributes that should not be in clusters
        for source2sas in output.sa_clusters.values():
            for sas in source2sas.values():
                for sa in sas:
                    original_sas_of_non_isolated_virtual_sas.add(sa.get_original_attribute())

        for sa in output.sa_isolated:
            # isolated virtual attributes must be completely removed
            if sa.is_generated():
                sas_generated_to_remove.add(sa)
            # isolated original attributes that gave rise to virtual attributes non-isolated must also be deleted
            elif sa in original_sas_of_non_isolated_virtual_sas:
                sas_original_to_delete.add(sa)
        for sa in sas_generated_to_remove:
            output.bdsa_data.remove_attribute(sa)
        output.set_sa_deleted(sas_original_to_delete)

        # for sa in list(output.sa_isolated):
        #     if sa.is_generated() or sa in sas_non_isolated:
        #         #TODO is this ok with the fact that sa_isolated is a generated property?
        #         output.sa_isolated.remove(sa)
        #         if sa.is_generated():
        #             output.bdsa_data.remove_attribute(sa)
        #         else:
        #             output.sa_deleted.add(sa)
        if pipeline_tag.ATOMIC_VALUES in self.debug_stats[cat]:
            del self.debug_stats[cat][pipeline_tag.ATOMIC_VALUES]

        return output

    def _remove_useless_clusters(self, clustering_output:ClusteringOutput):
        """Remove clusters containing only virtual attributes, and whose original attributes
         are ALL present in a single cluster """

        cids_to_delete = set()
        sa2cid = clustering_output.get_sa2cid()
        for cid, source2sas in clustering_output.sa_clusters.items():
            sasf = [sa for sas in source2sas.values() for sa in sas]
            #All attributes must be generated
            if all(sa.is_generated() for sa in sasf):
                # All original attributes must be in the same single cluster and non-isolated
                all_cids = {sa2cid.get(sa.get_original_attribute(),'ISOLATED') for sa in sasf}
                if len(all_cids) == 1 and 'ISOLATED' not in all_cids:
                    cids_to_delete.add(cid)
                    for sa in sasf:
                        clustering_output.bdsa_data.remove_attribute(sa)
        for cid in cids_to_delete:
            del clustering_output.sa_clusters[cid]

    def _remove_contained_clusters(self, clusters:ClusteringOutput):
        """
        Remove virtual attributes that are subsets of other attributes in the same cluster
        :param clusters:
        :return:
        """
        sa2urls = clusters.bdsa_data.sa2urls
        sa_to_delete = set()
        for cid, source2sas in clusters.sa_clusters.items():
            for source, sas in list(source2sas.items()):
                # Separate cluster attributes of this source in generated and atomic,
                # and group generated by its original version
                sa_origin2sas_generated = collections.defaultdict(set)
                sa_atomic = set()
                for sa in sas:
                    if sa.is_generated():
                        sa_origin2sas_generated[sa.get_original_attribute()].add(sa)
                    else:
                        sa_atomic.add(sa)
                for sa_orig, sas_generated in sa_origin2sas_generated.items():
                    # If cluster contain original attribute, then remove all generated.
                    if sa_orig in sa_atomic:
                        sa_to_delete.update(sas_generated)
                        source2sas[source].difference_update(sas_generated)
                    else:
                        # Detect which virtual are complete subset of another and delete them.
                        sa_gen2all_urls = {sa: sa2urls[sa] for sa in sas_generated}
                        sa_gen_all_contained = bdsa_utils.find_contained(sa_gen2all_urls)
                        sa_to_delete.update(sa_gen_all_contained)
                        source2sas[source].difference_update(sa_gen_all_contained)
        for sa in sa_to_delete:
            clusters.bdsa_data.remove_attribute(sa)
